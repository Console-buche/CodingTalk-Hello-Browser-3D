/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.13 psycanon.gltf -o Weapon.tsx -t -k -T 
Files: psycanon.gltf [8.68MB] > psycanon-transformed.glb [489.5KB] (94%)
*/

import { useSpring, easings, a } from '@react-spring/three'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import { useRef, useState } from 'react'
import * as THREE from 'three'
import { GLTF } from 'three-stdlib'
import { TalkMachineContext } from '../../../machines/talkMachine.context'

type GLTFResult = GLTF & {
  nodes: {
    Object_4: THREE.Mesh
    Object_6: THREE.Mesh
    Object_8: THREE.Mesh
    Object_10: THREE.Mesh
  }
  materials: {
    material_0: THREE.MeshStandardMaterial
    material_1: THREE.MeshStandardMaterial
    material_2: THREE.MeshStandardMaterial
    material_3: THREE.MeshStandardMaterial
  }
}
export function PsyCanon(props: JSX.IntrinsicElements['group']) {
  const { nodes, materials } = useGLTF('/psycanon-transformed.glb') as GLTFResult
  const refCanon = useRef<THREE.Group>(null)
  const [isHolding, setIsHolding] = useState(false)
  const refSpin = useRef<THREE.Mesh>(null)
  const [state] = TalkMachineContext.useActor()

  const { posy } = useSpring({
    posy: state.context.currentStep >= 5 ? props.position[1] : 0,
    config: {
      duration: 550,
      easing: easings.easeInOutBack
    }
  })

  useFrame(({ camera, clock }) => {
    if (!refCanon.current || !refSpin.current) {
      return
    }

    refSpin.current.rotateY(0.1)
    if (isHolding) {
      const lookAtPos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(10))
      refCanon.current.lookAt(lookAtPos)
      const offset = new THREE.Vector3(0, -0.3, -0.3) // Adjust these values
      offset.applyQuaternion(camera.quaternion)
      const pos = camera.position.clone().add(offset)
      refCanon.current.position.copy(pos)
      // refCanon.current.rotation.z = camera.rotation.z
      // ii
      //
      //
      return
    }

    refCanon.current.rotation.y += 0.01
    refCanon.current.position.y = Math.sin(clock.getElapsedTime()) * 0.1 + props.position[1]

    if (!isHolding && camera.position.distanceTo(refCanon.current.position) < 1.5) {
      setIsHolding(true)
    }
  })

  return (
    <a.group ref={refCanon} {...props} position-y={posy} dispose={null}>
      <mesh
        castShadow
        name="Object_4"
        geometry={nodes.Object_4.geometry}
        material={materials.material_0}
        position={[0.016, 0.043, 0.246]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={0.733}
      />
      <mesh
        name="Object_6"
        castShadow
        geometry={nodes.Object_6.geometry}
        material={materials.material_1}
        position={[0.01, 0.042, 0.163]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={0.733}
      />
      <mesh
        name="Object_8"
        geometry={nodes.Object_8.geometry}
        material={materials.material_2}
        castShadow
        position={[0.077, 0.077, -0.068]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={0.733}
      />
      <mesh
        ref={refSpin}
        name="Object_10"
        geometry={nodes.Object_10.geometry}
        material={materials.material_3}
        castShadow
        position={[0, 0.059, 0.265]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={0.733}
      />
    </a.group>
  )
}

useGLTF.preload('/psycanon-transformed.glb')
